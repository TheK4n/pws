#!/usr/bin/env python3.10
import datetime
import os
import sys
from getpass import getpass
from base64 import b64encode, b64decode
import hashlib
from time import sleep

from Cryptodome.Cipher import AES
from Cryptodome.Random import get_random_bytes
from json import dump, load

__version__ = '0.2 beta'

title = fr"""

         Password Storage
  _____   __          __   _____ 
 |  __ \  \ \        / /  / ____|
 | |__) |  \ \  /\  / /  | (___  
 |  ___/    \ \/  \/ /    \___ \ 
 | |         \  /\  /     ____) |
 |_|          \/  \/     |_____/   by TheK4n

Github  : https://github.com/TheK4n
Version : {__version__}

"""

help_title = r"""
add "service"
get "service"
rm "service"

set "setting"

quit
exit
q
"""


history = '.pws_history'
services = '.pws_services'
settings = '.pws_settings'
shadow = '.pws_shadow'


class Console:

    prompt = '\npws > '

    def __init__(self, master_passwd):
        self.hst_file = open(history, 'a')
        self.master = Master(master_passwd)

        if not os.path.exists(shadow):
            self.master.write("root")

        if not os.path.exists(settings):
            with open(settings, 'w') as file:
                dump({"chtime": 60}, file, indent=4, ensure_ascii=False)

        if not os.path.exists(history):
            with open(history, 'w'):
                pass

        if not os.path.exists(services):
            os.mkdir(services)

    def __add(self, service_name: str):

        login = input("login: ")
        passwd = getpass("Enter password: ")
        passwd_rep = getpass("Repeat password: ")
        if passwd_rep == passwd:
            service = Service(self.master.password, service_name)
            service.save(login, passwd)
            print(f"[+] Added {service_name}")
        else:
            print('[X] Passwords did not match')

    def __get(self, service_name):

        service = Service(self.master.password, service_name)
        try:
            l, p = service.get()
        except FileNotFoundError:
            print("[X] Service not found")
        else:
            print(f"\n[*] Service \"{service_name}\":\n\tLogin: {l}\n\tPassword: {p}")

    def __rm(self, service_name):
        service = Service(self.master.password, service_name)
        try:
            service.remove()
        except FileNotFoundError:
            print("[X] Service not found")

    def __set(self, setting: str):
        match setting:
            case "master":

                new_master = getpass("Enter new master password: ")
                new_master_repeated = getpass("Repeat new master password: ")
                if new_master == new_master_repeated:
                    self.master.write(new_master)
                    print("[+] Setting master changed")

    def loop(self):
        while True:
            command = input(self.prompt)
            self.hst_file.write(command + '\n')

            match command.split():
                case "add", service_name:
                    self.__add(service_name)

                case "get", service_name:
                    self.__get(service_name)

                case "set", setting:
                    self.__set(setting)

                case "rm", service_name:
                    self.__rm(service_name)

                case ["ls"]:
                    for i in os.listdir(services):
                        print(i)

                case ['c'] | ['clear']:
                    os.system(["cls", "clear"][os.name == 'posix'])

                case ["q"] | ["exit"] | ["quit"]:
                    print('\n[-] PWS stopped')
                    exit(1)

                case ["help"]:
                    print(help_title)

                case _:
                    print(f"\n[-] Unknown command")

    @staticmethod
    def get_expired_passwords():
        res = []

        chtime = int(load(open(settings, 'r'))["chtime"])

        for s in os.listdir(services):
            if datetime.datetime.now() - datetime.datetime.strptime(load(open(os.path.join(services, s), 'r'))["time"],
                                                                    '%Y-%m-%d') \
                    > datetime.timedelta(chtime):
                res.append(s)
        if res:
            print("[*] Expired:")
            c = 0
            for i in res:
                if c >= 3:
                    print(i)
                    c = 0
                else:
                    print(i, end="\t")
                    c += 1


class Master:

    SALT_LENGTH = 128  # move to settings
    HASH_METHOD = 'sha512'
    HASH_COUNT = 100000

    def __init__(self, password):
        self.password = password
        self.encoded_password = self.__encode_master_password(password)

    def __encode_master_password(self, passwd):
        salt = os.urandom(self.SALT_LENGTH)
        return salt + hashlib.pbkdf2_hmac(self.HASH_METHOD, passwd.encode('utf-8'), salt, self.HASH_COUNT)

    @staticmethod
    def change_master_in_services(old_master, new_master):
        for s in os.listdir(services):
            service = Service(old_master, s)
            l, p = service.get()
            service.remove()
            service = Service(new_master, s)
            service.save(l, p)

    def write(self, password=None):
        with open(shadow, 'wb') as file:
            if password:
                self.change_master_in_services(self.password, password)
                self.password = password
                self.encoded_password = self.__encode_master_password(password)
                file.write(self.encoded_password)
            else:
                file.write(self.encoded_password)
                self.change_master_in_services(self.password, password)

    @staticmethod
    def __get_master_hash():
        with open(shadow, 'rb') as file:
            return file.read()

    @property
    def hash(self):
        return self.__get_master_hash()

    def check(self) -> bool:
        master_hash = self.hash
        salt_from_storage = master_hash[:self.SALT_LENGTH]
        key_from_storage = master_hash[self.SALT_LENGTH:]
        key = hashlib.pbkdf2_hmac(self.HASH_METHOD, self.password.encode('utf-8'), salt_from_storage, self.HASH_COUNT)
        return key == key_from_storage


class Service:
    forbidden_symbols = r'\|/:,*?"<>+.%!@'.split()

    def __init__(self, master, service_name,):
        for sym in service_name:
            if sym in self.forbidden_symbols:
                raise MyError("wrong symbol")

        self.master = master
        self.service_name = service_name

    def __str__(self):
        return self.service_name

    def save(self, login, password):

        self.login = login
        self.password = password
        self.cipher = self.__encrypt(self.master)

        encrypted_passwd = {"hash": self.cipher}
        encrypted_passwd.update({"login": self.login, "time": str(datetime.datetime.now().date())})

        with open(os.path.join(services, self.service_name), 'w') as file:
            dump(encrypted_passwd, file, indent=4, ensure_ascii=False)

    def get(self):
        with open(os.path.join(services, self.service_name), 'r') as file:
            return load(file)["login"], self.__decrypt(self.master)

    def remove(self):
        os.remove(os.path.join(services, self.service_name))

    def __encrypt(self, master) -> str:
        salt = get_random_bytes(AES.block_size)

        private_key = hashlib.scrypt(
            master.encode(), salt=salt, n=2 ** 14, r=8, p=1, dklen=32)

        cipher_config = AES.new(private_key, AES.MODE_GCM)

        cipher_text, tag = cipher_config.encrypt_and_digest(self.password.encode('utf-8'))

        return f"{b64encode(salt).decode('utf-8')}" \
               f"{b64encode(cipher_config.nonce).decode('utf-8')}" \
               f"{b64encode(tag).decode('utf-8')}" \
               f"{b64encode(cipher_text).decode('utf-8')}"

    def get_hash(self):
        with open(os.path.join(services, self.service_name), 'r') as file:
            return load(file)["hash"]

    def __parse_hash(self, block_size=24) -> tuple:

        cipher = self.get_hash()
        return tuple(map(b64decode, (cipher[:block_size], cipher[block_size:block_size * 2],
                                     cipher[block_size * 2:block_size * 3], cipher[block_size * 3:])))

    def __decrypt(self, master) -> str:
        """

        :raises ValueError
        :param master:
        :return:
        """
        salt, nonce, tag, cipher_text = self.__parse_hash()
        # generate the private key from the password and salt
        private_key = hashlib.scrypt(
            master.encode(), salt=salt, n=2 ** 14, r=8, p=1, dklen=32)

        # create the cipher config
        cipher = AES.new(private_key, AES.MODE_GCM, nonce=nonce)

        # decrypt the cipher text
        return cipher.decrypt_and_verify(cipher_text, tag).decode('utf-8')


class MyError(Exception):
    pass


def main():

    console = Console(getpass(prompt="[*] Master password: "))
    if console.master.check():
        console.loop()
    else:
        print("\n[X] Wrong password", file=sys.stderr)
        sleep(5)
        exit(1)


if __name__ == '__main__':
    try:
        main()
    except EOFError:
        print('\n[-] PWS stopped', file=sys.stderr)
        exit(1)
    except KeyboardInterrupt:
        print('\n[-] PWS stopped', file=sys.stderr)
        exit(130)
    finally:
        os.system(["cls", "clear"][os.name == 'posix'])
