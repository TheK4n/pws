#!/usr/bin/env python3.10
import datetime
import os
import sys
from getpass import getpass
from base64 import b64encode, b64decode
import hashlib
from time import sleep

from Cryptodome.Cipher import AES
from Cryptodome.Random import get_random_bytes
from json import dump, load

__version__ = '0.1'

title = fr"""

         Password Storage
  _____   __          __   _____ 
 |  __ \  \ \        / /  / ____|
 | |__) |  \ \  /\  / /  | (___  
 |  ___/    \ \/  \/ /    \___ \ 
 | |         \  /\  /     ____) |
 |_|          \/  \/     |_____/   by TheK4n

Github  : https://github.com/TheK4n
Version : {__version__}

"""

help_title = r"""
add "service"
get "service"
rm "service"

set "setting"

quit
exit
q
"""
prompt = '\npws > '

SALT_LENGTH = 128  # move to settings
HASH_METHOD = 'sha512'
HASH_COUNT = 100000

shadow = '.pws_shadow'
history = '.pws_history'
services = '.pws_services'
settings = '.pws_settings'

hst_file = open(history, 'a')


class MyError(Exception):
    pass


def init_all():
    if not os.path.exists(shadow):
        write_master_passwd("root")

    if not os.path.exists(settings):
        with open(settings, 'w') as file:
            dump({"chtime": 60}, file, indent=4, ensure_ascii=False)

    if not os.path.exists(history):
        with open(history, 'w'):
            pass

    if not os.path.exists(services):
        os.mkdir(services)


def write_master_passwd(passwd):
    salt = os.urandom(SALT_LENGTH)
    key = hashlib.pbkdf2_hmac(HASH_METHOD, passwd.encode('utf-8'), salt, HASH_COUNT)

    with open(shadow, 'wb') as file:
        file.write(salt + key)


def check_master_passwd(passwd) -> bool:
    with open(shadow, 'rb') as file:
        pass_hash = file.read()

    salt_from_storage = pass_hash[:SALT_LENGTH]
    key_from_storage = pass_hash[SALT_LENGTH:]
    del pass_hash

    key = hashlib.pbkdf2_hmac(HASH_METHOD, passwd.encode('utf-8'), salt_from_storage, HASH_COUNT)
    del salt_from_storage
    return key == key_from_storage


def get_passwd_aes(passwd, master) -> str:
    salt = get_random_bytes(AES.block_size)

    private_key = hashlib.scrypt(
        master.encode(), salt=salt, n=2**14, r=8, p=1, dklen=32)

    cipher_config = AES.new(private_key, AES.MODE_GCM)

    cipher_text, tag = cipher_config.encrypt_and_digest(passwd.encode('utf-8'))

    return f"{b64encode(salt).decode('utf-8')}" \
           f"{b64encode(cipher_config.nonce).decode('utf-8')}" \
           f"{b64encode(tag).decode('utf-8')}" \
           f"{b64encode(cipher_text).decode('utf-8')}"


def get_passwd_from_aes(enc_hash, master) -> str:
    salt = b64decode(enc_hash[:24])
    nonce = b64decode(enc_hash[24:24 * 2])
    tag = b64decode(enc_hash[48:24 * 3])
    cipher_text = b64decode(enc_hash[24 * 3:])

    # generate the private key from the password and salt
    private_key = hashlib.scrypt(
        master.encode(), salt=salt, n=2 ** 14, r=8, p=1, dklen=32)

    # create the cipher config
    cipher = AES.new(private_key, AES.MODE_GCM, nonce=nonce)

    # decrypt the cipher text
    try:
        decrypted = cipher.decrypt_and_verify(cipher_text, tag)
    except ValueError:
        print("[X] Wrong cipher", file=sys.stderr)
    else:
        return decrypted.decode('utf-8')


def add_new_service(service_name, login, password, master):
    forbidden_symbols = r'\|/:,*?"<>+.%!@'.split()

    for sym in service_name:
        if sym in forbidden_symbols:
            raise MyError("wrong symbol")

    encrypted_passwd = {"hash": get_passwd_aes(password, master)}
    encrypted_passwd.update({"login": login, "time": str(datetime.datetime.now().date())})

    with open(os.path.join(services, service_name), 'w') as file:
        dump(encrypted_passwd, file, indent=4, ensure_ascii=False)


def get_service(service_name, master):
    with open(os.path.join(services, service_name), 'r') as file:
        data = load(file)
        return data["login"], get_passwd_from_aes(data['hash'], master)


def change_master_in_services(old_master, new_master):
    for s in os.listdir(services):
        l, p = get_service(s, old_master)
        os.remove(os.path.join(services, s))
        add_new_service(s, l, p, new_master)


def get_expired_passwords():
    res = []

    chtime = int(load(open(settings, 'r'))["chtime"])

    for s in os.listdir(services):
        if datetime.datetime.now() - datetime.datetime.strptime(load(open(os.path.join(services, s), 'r'))["time"],
                                                                '%Y-%m-%d') \
                > datetime.timedelta(chtime):
            res.append(s)
    if res:
        print("[*] Expired:")
    c = 0
    for i in res:
        if c >= 3:
            print(i)
            c = 0
        else:
            print(i, end="\t")
            c += 1


def main_console():
    get_expired_passwords()
    while True:
        command = input(prompt)
        hst_file.write(command + '\n')

        match command.split():
            case "add", service_name:

                master = getpass("Enter master password: ")
                if not check_master_passwd(master):
                    print("[X] Wrong master")
                    continue
                login = input("login: ")
                passwd = getpass("Enter password: ")
                passwd_rep = getpass("Repeat password: ")
                if passwd_rep == passwd:
                    add_new_service(service_name, login, passwd, master)
                    print(f"[+] Added {service_name}")
                else:
                    print('[X] Passwords did not match')

            case "get", service_name:
                try:
                    l, p = get_service(service_name, getpass("Enter master password: "))
                except FileNotFoundError:
                    print("[X] Service not found")
                else:
                    print(f"\n[*] Service \"{service_name}\":\n\tLogin: {l}\n\tPassword: {p}")

            case "set", setting:
                match setting:
                    case "master":
                        old_master = getpass("Enter old master password: ")
                        new_master = getpass("Enter new master password: ")
                        new_master_repeated = getpass("Repeat new master password: ")
                        if new_master == new_master_repeated:
                            write_master_passwd(new_master)
                            del new_master_repeated
                            change_master_in_services(old_master, new_master)
                            del new_master, old_master
                            print("[+] Setting master changed")

            case "rm", service_name:
                try:
                    os.remove(os.path.join(services, service_name))
                except FileNotFoundError:
                    print("[X] Service not found")

            case ["ls"]:
                for i in os.listdir(services):
                    print(i)

            case ['c'] | ['clear']:
                os.system(["cls", "clear"][os.name == 'posix'])

            case ["q"] | ["exit"] | ["quit"]:
                print('\n[-] PWS stopped')
                exit(1)

            case ["help"]:
                print(help_title)

            case _:
                print(f"\n[-] Unknown command")


def main():
    init_all()
    print(title)

    if check_master_passwd(getpass(prompt="[*] Master password: ")):
        main_console()
    else:
        print("\n[X] Wrong password", file=sys.stderr)
        sleep(5)
        exit(1)


if __name__ == '__main__':
    try:
        main()
    except EOFError:
        print('\n[-] PWS stopped', file=sys.stderr)
        exit(1)
    except KeyboardInterrupt:
        print('\n[-] PWS stopped', file=sys.stderr)
        exit(130)
    finally:
        hst_file.close()
        os.system(["cls", "clear"][os.name == 'posix'])
